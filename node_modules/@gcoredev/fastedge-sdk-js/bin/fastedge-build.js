#!/usr/bin/env node

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/arg/index.js
var require_arg = __commonJS({
  "node_modules/arg/index.js"(exports, module) {
    var flagSymbol = Symbol("arg flag");
    var ArgError = class extends Error {
      constructor(msg, code) {
        super(msg);
        this.name = "ArgError";
        this.code = code;
        Object.setPrototypeOf(this, ArgError.prototype);
      }
    };
    function arg2(opts, {
      argv = process.argv.slice(2),
      permissive = false,
      stopAtPositional = false
    } = {}) {
      if (!opts) {
        throw new ArgError(
          "argument specification object is required",
          "ARG_CONFIG_NO_SPEC"
        );
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts)) {
        if (!key) {
          throw new ArgError(
            "argument key cannot be an empty string",
            "ARG_CONFIG_EMPTY_KEY"
          );
        }
        if (key[0] !== "-") {
          throw new ArgError(
            `argument key must start with '-' but found: '${key}'`,
            "ARG_CONFIG_NONOPT_KEY"
          );
        }
        if (key.length === 1) {
          throw new ArgError(
            `argument key must have a name; singular '-' keys are not allowed: ${key}`,
            "ARG_CONFIG_NONAME_KEY"
          );
        }
        if (typeof opts[key] === "string") {
          aliases[key] = opts[key];
          continue;
        }
        let type = opts[key];
        let isFlag = false;
        if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
          const [fn] = type;
          type = (value, name, prev = []) => {
            prev.push(fn(value, name, prev[prev.length - 1]));
            return prev;
          };
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type === "function") {
          isFlag = type === Boolean || type[flagSymbol] === true;
        } else {
          throw new ArgError(
            `type missing or not a function or valid array type: ${key}`,
            "ARG_CONFIG_VAD_TYPE"
          );
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new ArgError(
            `short argument keys (with a single hyphen) must have only one character: ${key}`,
            "ARG_CONFIG_SHORTOPT_TOOLONG"
          );
        }
        handlers[key] = [type, isFlag];
      }
      for (let i = 0, len = argv.length; i < len; i++) {
        const wholeArg = argv[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg3 = separatedArguments[j];
            const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg3);
                continue;
              } else {
                throw new ArgError(
                  `unknown or unexpected option: ${originalArgName}`,
                  "ARG_UNKNOWN_OPTION"
                );
              }
            }
            const [type, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new ArgError(
                `option requires argument (but was followed by another short argument): ${originalArgName}`,
                "ARG_MISSING_REQUIRED_SHORTARG"
              );
            }
            if (isFlag) {
              result[argName] = type(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || // eslint-disable-next-line no-undef
              typeof BigInt !== "undefined" && type === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new ArgError(
                  `option requires argument: ${originalArgName}${extended}`,
                  "ARG_MISSING_REQUIRED_LONGARG"
                );
              }
              result[argName] = type(argv[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    arg2.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
    arg2.ArgError = ArgError;
    module.exports = arg2;
  }
});

// src/fastedge-build/index.js
var import_arg = __toESM(require_arg(), 1);

// src/componentize/index.js
import { spawnSync as spawnSync2 } from "node:child_process";
import { rmSync } from "node:fs";
import { readFile as readFile3, writeFile as writeFile2 } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
import { componentNew } from "@bytecodealliance/jco";
import wizer from "@bytecodealliance/wizer";

// src/componentize/add-wasm-metadata.js
import { readFile, writeFile } from "node:fs/promises";
import { metadataAdd } from "@bytecodealliance/jco";

// src/utils/file-system.js
import { readdirSync } from "node:fs";
import { mkdir, mkdtemp, readdir, stat } from "node:fs/promises";
import { tmpdir } from "node:os";
import path from "node:path";
import { fileURLToPath } from "node:url";

// src/utils/prompts.js
import enquirer from "enquirer";
var { Confirm, Input, MultiSelect, Select } = enquirer;
var NO_COLOUR = "\x1B[0m";
var promptColors = {
  error: "\x1B[31m",
  // Red
  success: "\x1B[32m",
  // Green
  warning: "\x1B[33m",
  // Yellow
  info: "\x1B[34m",
  // Blue
  caution: "\x1B[35m",
  // Magenta
  standard: NO_COLOUR
};
var colorLog = (color, ...restArgs) => {
  if (color === "error") {
    console.error(promptColors[color] ?? NO_COLOUR, ...restArgs, NO_COLOUR);
    return;
  }
  console.info(promptColors[color] ?? NO_COLOUR, ...restArgs, NO_COLOUR);
};

// src/utils/file-system.js
var npxPackagePath = (filePath) => {
  const __dirname = path.dirname(fileURLToPath(import.meta.url)).replace(/\/bin([^/]*)$/u, "");
  try {
    return path.resolve(__dirname, filePath);
  } catch {
    throw new Error(`Failed to resolve the npxPackagePath: ${filePath}`);
  }
};
async function createOutputDirectory(outputPath) {
  try {
    await mkdir(path.dirname(outputPath), {
      recursive: true
    });
  } catch (error) {
    colorLog(
      "error",
      `Error: Failed to create the "output" (${outputPath}) directory`,
      error.message
    );
    process.exit(1);
  }
}
async function isFile(filePath, allowNonexistent = false) {
  try {
    const stats = await stat(filePath);
    return stats.isFile();
  } catch (error) {
    if (error.code === "ENOENT") {
      return allowNonexistent;
    }
    throw error;
  }
}
async function getTmpDir() {
  return mkdtemp(path.normalize(tmpdir() + path.sep));
}
function resolveTmpDir(filePath) {
  return path.resolve(filePath, "temp.bundle.js");
}
function getFilesRecursively(inputPath, opts) {
  const { ignoreDirs = [], ignoreDotFiles = true, ignoreWellKnown = false } = opts;
  const files = [];
  const readDir = (dir) => {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const { name } = entry;
      const fullpath = path.resolve(dir, name);
      const relative = `/${path.relative(inputPath, fullpath)}`;
      if (ignoreDirs.includes(relative))
        continue;
      const removeWellKnown = ignoreWellKnown && name === ".well-known";
      if (removeWellKnown)
        continue;
      if (ignoreDotFiles && name.startsWith(".") && name !== ".well-known")
        continue;
      const res = path.resolve(dir, name);
      if (entry.isDirectory()) {
        readDir(res);
      } else {
        files.push(res);
      }
    }
  };
  readDir(inputPath);
  return files;
}

// src/componentize/add-wasm-metadata.js
async function addWasmMetadata(wasmPath) {
  const packageJson = await readFile(npxPackagePath("./package.json"), {
    encoding: "utf-8"
  });
  const { name, version } = JSON.parse(packageJson);
  const metadata = [["processed-by", [[name, version]]]];
  const wasm = await readFile(wasmPath);
  const newWasm = await metadataAdd(wasm, metadata);
  await writeFile(wasmPath, newWasm);
}

// src/componentize/get-js-input.js
import { readFile as readFile2 } from "node:fs/promises";

// src/componentize/es-bundle.js
import { build } from "esbuild";
var fastedgePackagePlugin = {
  name: "fastedge-package-plugin",
  setup(build2) {
    build2.onResolve({ filter: /^fastedge::.*/u }, (args2) => ({
      path: args2.path.replace("fastedge::", ""),
      namespace: "fastedge"
    }));
    build2.onLoad({ filter: /^.*/u, namespace: "fastedge" }, async (args2) => {
      switch (args2.path) {
        case "env": {
          return { contents: `export const getEnv = globalThis.fastedge.getEnv;` };
        }
        case "fs": {
          return { contents: `export const readFileSync = globalThis.fastedge.readFileSync;` };
        }
        case "secret": {
          return { contents: `export const getSecret = globalThis.fastedge.getSecret;` };
        }
        default: {
          return { contents: "" };
        }
      }
    });
  }
};
async function esBundle(input) {
  const contents = await build({
    entryPoints: [input],
    bundle: true,
    write: false,
    tsconfig: void 0,
    plugins: [fastedgePackagePlugin]
  });
  return contents.outputFiles[0].text;
}

// src/componentize/get-js-input.js
async function getJsInputContents(jsInput, preBundleJSInput) {
  if (preBundleJSInput) {
    return esBundle(jsInput);
  }
  return readFile2(jsInput, "utf8");
}

// src/componentize/precompile.js
import { parse } from "acorn";
import { simple as simpleWalk } from "acorn-walk";
import MagicString from "magic-string";
import regexpuc from "regexpu-core";
var PREAMBLE = `;{
  // Precompiled regular expressions
  const precompile = (r) => { r.exec('a'); r.exec('\\u1000'); };`;
var POSTAMBLE = "}";
function precompile(source, filename = "<input>") {
  const magicString = new MagicString(source, {
    filename
  });
  const ast = parse(source, {
    ecmaVersion: "latest",
    sourceType: "script"
  });
  const precompileCalls = [];
  simpleWalk(ast, {
    Literal(node) {
      if (!node.regex)
        return;
      let transpiledPattern;
      try {
        transpiledPattern = regexpuc(node.regex.pattern, node.regex.flags, {
          unicodePropertyEscapes: "transform"
        });
      } catch {
        transpiledPattern = node.regex.pattern;
      }
      const transpiledRegex = `/${transpiledPattern}/${node.regex.flags}`;
      precompileCalls.push(`precompile(${transpiledRegex});`);
      magicString.overwrite(node.start, node.end, transpiledRegex);
    }
  });
  if (precompileCalls.length === 0)
    return source;
  magicString.prepend(`${PREAMBLE}${precompileCalls.join("\n")}${POSTAMBLE}`);
  return magicString.toString();
}

// src/utils/input-path-verification.js
import { spawnSync } from "node:child_process";
function containsSyntaxErrors(jsInput) {
  const nodeProcess = spawnSync(`"${process.execPath}"`, ["--check", jsInput], {
    stdio: [null, null, null],
    shell: true,
    encoding: "utf-8"
  });
  if (nodeProcess.status === 0) {
    return false;
  }
  colorLog(
    "standard",
    `${nodeProcess.stderr.split("\nSyntaxError: Invalid or unexpected token\n")[0]}
`
  );
  colorLog("error", `SyntaxError: Invalid or unexpected token`);
  return true;
}
async function validateFilePaths(input, output, wasmEngine = npxPackagePath("./lib/fastedge-runtime.wasm")) {
  if (!await isFile(input)) {
    colorLog("error", `Error: Input "${input}" is not a file`);
    process.exit(1);
  }
  if (output.slice(-5) !== ".wasm") {
    colorLog("error", `Error: Output ${output} must be a .wasm file path`);
    process.exit(1);
  }
  if (!await isFile(output)) {
    createOutputDirectory(output);
    if (!await isFile(
      output,
      /* AllowNonexistent */
      true
    )) {
      colorLog("error", `Error: "${output}" path does not exist`);
      process.exit(1);
    }
  }
  if (!await isFile(wasmEngine)) {
    colorLog("error", `Error: "${wasmEngine}" is not a file`);
    process.exit(1);
  }
  if (containsSyntaxErrors(input)) {
    colorLog("error", `Error: "${input}" contains JS Errors`);
    process.exit(1);
  }
}

// src/componentize/index.js
async function componentize(jsInput, output, opts = {}) {
  const {
    debug = false,
    wasmEngine = await npxPackagePath("./lib/fastedge-runtime.wasm"),
    enableStdout = false,
    enablePBL = false,
    preBundleJSInput = true
  } = opts;
  const jsPath = fileURLToPath2(new URL(resolve(process.cwd(), jsInput), import.meta.url));
  const wasmOutputDir = fileURLToPath2(new URL(resolve(process.cwd(), output), import.meta.url));
  await validateFilePaths(jsPath, wasmOutputDir, wasmEngine);
  const contents = await getJsInputContents(jsPath, preBundleJSInput);
  const application = precompile(contents);
  const tmpDir = await getTmpDir();
  const outPath = resolveTmpDir(tmpDir);
  await writeFile2(outPath, application);
  const wizerInput = outPath;
  const cleanup = () => {
    rmSync(tmpDir, { recursive: true });
  };
  try {
    const wizerProcess = spawnSync2(
      wizer,
      [
        "--allow-wasi",
        `--wasm-bulk-memory=true`,
        "--inherit-env=true",
        "--dir=.",
        // '--dir=../', // todo: Farq: NEED to iterate config file and add these paths for static building...
        `--dir=${dirname(wizerInput)}`,
        "-r _start=wizer.resume",
        `-o=${wasmOutputDir}`,
        wasmEngine
      ],
      {
        stdio: [null, process.stdout, process.stderr],
        input: wizerInput,
        shell: true,
        encoding: "utf-8",
        env: {
          // ENABLE_EXPERIMENTAL_HIGH_RESOLUTION_TIME_METHODS:
          //   enableExperimentalHighResolutionTimeMethods ? "1" : "0",
          ENABLE_PBL: enablePBL ? "1" : "0"
          // ...process.env,
        }
      }
    );
    if (wizerProcess.status !== 0) {
      throw new Error(`Wizer initialization failure`);
    }
    process.exitCode = wizerProcess.status;
  } catch (error) {
    if (process.env.NODE_ENV !== "test") {
      console.error("Error: Failed to compile JavaScript to Wasm:", error.message);
    }
    process.exit(1);
  } finally {
    cleanup();
  }
  const coreComponent = await readFile3(output);
  const adapter = fileURLToPath2(
    new URL(npxPackagePath("./lib/preview1-adapter.wasm"), import.meta.url)
  );
  const generatedComponent = await componentNew(coreComponent, [
    ["wasi_snapshot_preview1", await readFile3(adapter)]
  ]);
  await writeFile2(output, generatedComponent);
  await addWasmMetadata(output);
}

// src/fastedge-build/config-build/build-wasm.js
async function buildWasm({ input, output }) {
  await validateFilePaths(input, output);
  if (process.env.NODE_ENV !== "test") {
    await componentize(input, output);
  }
}

// src/fastedge-build/config-build/index.js
import path5 from "node:path";

// src/fastedge-build/config-build/build-manifest/create-static-manifest.js
import { writeFileSync } from "node:fs";
import path4 from "node:path";

// src/fastedge-build/config-build/build-manifest/create-manifest.js
import path3 from "node:path";

// src/utils/content-types.js
var textFormats = [
  // Order is important
  { test: /.txt$/, contentType: "text/plain" },
  { test: /.htm(l)?$/, contentType: "text/html" },
  { test: /.xml$/, contentType: "application/xml" },
  { test: /.json$/, contentType: "application/json" },
  { test: /.map$/, contentType: "application/json" },
  { test: /.js$/, contentType: "application/javascript" },
  { test: /.css$/, contentType: "text/css" },
  { test: /.svg$/, contentType: "image/svg+xml" }
];
var binaryFormats = [
  // Order is important
  { test: /.bmp$/, contentType: "image/bmp" },
  { test: /.png$/, contentType: "image/png" },
  { test: /.gif$/, contentType: "image/gif" },
  { test: /.jp(e)?g$/, contentType: "image/jpeg" },
  { test: /.ico$/, contentType: "image/vnd.microsoft.icon" },
  { test: /.tif(f)?$/, contentType: "image/png" },
  { test: /.aac$/, contentType: "audio/aac" },
  { test: /.mp3$/, contentType: "audio/mpeg" },
  { test: /.avi$/, contentType: "video/x-msvideo" },
  { test: /.mp4$/, contentType: "video/mp4" },
  { test: /.mpeg$/, contentType: "video/mpeg" },
  { test: /.webm$/, contentType: "video/webm" },
  { test: /.pdf$/, contentType: "application/pdf" },
  { test: /.tar$/, contentType: "application/x-tar" },
  { test: /.zip$/, contentType: "application/zip" },
  { test: /.eot$/, contentType: "application/vnd.ms-fontobject" },
  { test: /.otf$/, contentType: "font/otf" },
  { test: /.ttf$/, contentType: "font/ttf" },
  { test: /.woff$/, contentType: "font/woff" },
  { test: /.woff2$/, contentType: "font/woff2" }
];
var defaultContentTypes = [
  // Farq: May need to track this "text" status for kvStore implementation
  // ...textFormats.map((contentType) => ({ ...contentType, text: true })),
  // ...binaryFormats.map((contentType) => ({ ...contentType, text: false })),
  ...textFormats.map((contentType) => ({ ...contentType })),
  ...binaryFormats.map((contentType) => ({ ...contentType }))
];
function getKnownContentTypes(customContentTypes) {
  const finalContentTypes = [];
  if (!Array.isArray(customContentTypes)) {
    colorLog("caution", "customContentTypes not an array, ignoring.");
  } else {
    for (const [index, contentType] of customContentTypes.entries()) {
      let invalid = false;
      if (typeof contentType.test !== "function" && !(contentType.test instanceof RegExp)) {
        colorLog(
          "caution",
          `Ignoring customContentTypes[${index}]: 'test' must be a function or regular expression.`
        );
        invalid = true;
      }
      if (typeof contentType.contentType !== "string" || !contentType.contentType.includes("/")) {
        colorLog(
          "caution",
          `Ignoring customContentTypes[${index}]: 'contentType' must be a valid string.`
        );
        invalid = true;
      }
      if (!invalid) {
        finalContentTypes.push({
          test: contentType.test,
          contentType: contentType.contentType
        });
      }
    }
  }
  colorLog("info", `Applying ${finalContentTypes.length} custom content type(s).`);
  for (const contentType of defaultContentTypes) {
    finalContentTypes.push(contentType);
  }
  return finalContentTypes;
}
function testFileContentType(contentTypes, assetKey) {
  for (const contentType of contentTypes ?? defaultContentTypes) {
    let matched = false;
    contentType.test instanceof RegExp ? matched = contentType.test.test(assetKey) : matched = contentType.test(assetKey);
    if (matched) {
      return { contentType: contentType.contentType };
    }
  }
  return null;
}

// src/utils/file-info.js
import crypto from "node:crypto";
import { readFileSync, statSync } from "node:fs";
import path2 from "node:path";
function createFileInfo(assetKey, publicDir, file) {
  const stats = statSync(file);
  const lastModifiedTime = Math.floor(stats.mtime.getTime() / 1e3);
  const fileBuffer = readFileSync(file);
  const size = fileBuffer.length;
  const hash = crypto.createHash("sha256");
  hash.update(fileBuffer);
  const assetPath = `./${path2.join(publicDir, assetKey)}`;
  return {
    size,
    hash: hash.digest("hex"),
    lastModifiedTime,
    assetPath
  };
}

// src/fastedge-build/config-build/build-manifest/create-manifest.js
function prettierObjectString(obj) {
  const contentsStr = Object.entries(obj).reduce((acc, [key, value]) => {
    let strVal = value;
    if (typeof value === "string") {
      strVal = `'${value}'`;
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
      } else {
        strVal = prettierObjectString(value);
      }
    }
    return `${acc.length > 0 ? `${acc}, ` : ""}${key}: ${strVal}`;
  }, "");
  return `{ ${contentsStr} }`;
}
function createManifestFileMap(config) {
  const publicDirPath = path3.resolve(config.publicDir);
  colorLog("info", `Using ${publicDirPath} as public directory`);
  if (config.ignoreDirs.length > 0) {
    colorLog("info", `Ignoring directories:`);
    for (const ignoreDir of config.ignoreDirs) {
      colorLog("info", `    - ${ignoreDir}`);
    }
  }
  const files = getFilesRecursively(publicDirPath, {
    ignoreDirs: config.ignoreDirs,
    ignoreDotFiles: config.ignoreDotFiles,
    ignoreWellKnown: config.ignoreWellKnown
  });
  config.ignoreDotFiles ? colorLog("info", "Removed dot files (default behavior)") : colorLog(
    "warning",
    "Included dot files (Caution!! - .env, .gitignore, etc. may be included)"
  );
  config.ignoreWellKnown ? colorLog("warning", "Ignored .well-known (This may cause issues with web manifests, etc.)") : colorLog("info", "Included .well-known");
  const knownContentTypes = getKnownContentTypes(config.contentTypes);
  colorLog("info", "Creating build manifest...");
  const manifestAssets = files.map((file) => {
    const assetKey = file.replace(publicDirPath, "");
    let contentTypeInfo = testFileContentType(knownContentTypes, assetKey);
    if (!contentTypeInfo) {
      colorLog(
        "caution",
        `Unknown content type for ${assetKey}. Defaulting to application/octet-stream`
      );
      contentTypeInfo = {
        contentType: "application/octet-stream"
      };
    }
    const fileInfo = createFileInfo(assetKey, config.publicDir, file);
    return {
      assetKey,
      ...contentTypeInfo,
      // fileInfo: createFileInfo(assetKey, config.publicDir, file),
      fileInfo,
      // todo: fix these.. to our shape
      lastModifiedTime: fileInfo.lastModifiedTime,
      type: "wasm-inline"
    };
  });
  const staticAssetManifest = {};
  for (const assetInfo of manifestAssets) {
    staticAssetManifest[assetInfo.assetKey] = assetInfo;
  }
  return staticAssetManifest;
}

// src/fastedge-build/config-build/build-manifest/create-static-manifest.js
async function createStaticManifest(config) {
  const outputFile = ".fastedge/build/static-server-manifest.js";
  const manifestBuildOutput = path4.resolve(outputFile);
  await createOutputDirectory(manifestBuildOutput);
  colorLog("info", `Creating build manifest in ${manifestBuildOutput}`);
  const staticAssetManifest = await createManifestFileMap(config);
  const readableAssetLines = Object.entries(staticAssetManifest).map(
    ([key, value]) => `  '${key}': ${prettierObjectString(value)},`
  );
  const manifestFileContents = [
    "/*",
    " * DO NOT EDIT THIS FILE - Generated by @gcoredev/FastEdge-sdk-js",
    " *",
    " * It will be overwritten on the next build.",
    " */",
    "",
    "const staticAssetManifest = {",
    ...readableAssetLines,
    "};",
    "",
    "export { staticAssetManifest  };",
    ""
  ];
  writeFileSync(manifestBuildOutput, manifestFileContents.join("\n"));
}

// src/utils/config-helpers.js
var removeDotSlashPrefix = (str) => str.replace(/^\.\//u, "");
var removeTrailingSlash = (str) => str.replace(/\/+$/u, "");
function normalizePath(path6 = "", prefix = "") {
  let normalizedPath = removeDotSlashPrefix(path6);
  normalizedPath = removeTrailingSlash(normalizedPath);
  if (!normalizedPath.startsWith("/")) {
    normalizedPath = `/${normalizedPath}`;
  }
  return `${prefix}${normalizedPath}`;
}
function defaultedBoolean(defaultValue) {
  return (value) => value ?? defaultValue;
}
function normalizeArrayOfPaths(pathsArray = []) {
  return pathsArray.map((p) => normalizePath(p));
}
function normalizeBuildConfig(config = {}) {
  const buildConfigNormalizeFns = {
    ignoreDotFiles: defaultedBoolean(true),
    ignoreWellKnown: defaultedBoolean(false),
    ignoreDirs: normalizeArrayOfPaths
  };
  return normalizeConfig(config, buildConfigNormalizeFns);
}
function normalizeConfig(config, normalizeFns) {
  return Object.entries(config).reduce(
    (acc, [key, value]) => {
      const normalizeFn = normalizeFns[key];
      return {
        ...acc,
        [key]: normalizeFn ? normalizeFn(value) : value
      };
    },
    /** @type {T} */
    {}
  );
}

// src/fastedge-build/config-build/index.js
async function buildFromConfig(config) {
  if (!config)
    return;
  switch (config.type) {
    case "static": {
      await createStaticManifest(config);
      await buildWasm(config);
      colorLog("success", `Success: Built ${config.output}`);
      break;
    }
    case "http": {
      await buildWasm(config);
      colorLog("success", `Success: Built ${config.output}`);
      break;
    }
    case "next": {
      console.log("Farq: next build - Not yet implemented");
      break;
    }
    default: {
      colorLog("error", "Error: Invalid config type. Must be one of: static, http, next.");
      break;
    }
  }
}
async function loadConfig(configPath) {
  try {
    const configFileExists = await isFile(configPath);
    if (configFileExists) {
      const { config } = await import(
        /* webpackChunkName: "config" */
        configPath
      );
      return normalizeBuildConfig(config);
    }
    colorLog("error", `Error: Config file not found at ${configPath}. Skipping build.`);
  } catch (error) {
    colorLog("error", "Error loading config:", error);
    throw error;
  }
}
async function buildFromConfigFiles(configFilePaths = []) {
  for (const configFilePath of configFilePaths) {
    const configPath = path5.resolve(configFilePath);
    await buildFromConfig(await loadConfig(configPath));
  }
  process.exit(0);
}

// src/fastedge-build/print-info.js
import { readFileSync as readFileSync2 } from "node:fs";
var USAGE_TEXT = `
Usage: fastedge-build [options]

  Options:

  --help, -h      Print this help information
  --version, -v   Print the version number
  --input, -i     <input-file> Js filepath to build (e.g. ./src/index.js)
  --ouput, -o     <output-file> Output filepath for wasm (e.g. ./dist/main.wasm)
  --config, -c    <config-file> Path to a build config file (default: ./.fastedge/build-config.js)
`;
async function printVersion() {
  const { version } = JSON.parse(readFileSync2(npxPackagePath("./package.json"), "utf8"));
  colorLog("standard", `@gcoredev/fastedge-sdk-js: ${version}`);
}
function printHelp() {
  colorLog("standard", USAGE_TEXT);
}

// src/constants/index.js
var PROJECT_DIRECTORY = ".fastedge";
var CONFIG_FILE_PATH = `${PROJECT_DIRECTORY}/build-config.js`;

// src/fastedge-build/index.js
var inputFileName = "";
var outputFileName = "";
var configFiles = [];
var args;
try {
  args = (0, import_arg.default)(
    {
      // Types
      "--version": Boolean,
      "--help": Boolean,
      "--input": String,
      "--output": String,
      "--config": [String],
      // Aliases
      "-v": "--version",
      "-h": "--help",
      "-i": "--input",
      "-o": "--output",
      "-c": "--config"
    },
    {
      permissive: true
    }
  );
} catch (error) {
  if (error.toString().includes("option requires argument: -c")) {
    args = { _: [], "--config": [CONFIG_FILE_PATH] };
  } else {
    printHelp();
    process.exit(0);
  }
}
var hasFileInputsOnly = (args._.length === 1 || args._.length === 2) && Object.keys(args).length === 1;
var hasOptionsOnly = Object.keys(args).length > 1 && args._.length === 0;
var hasValidInput = hasFileInputsOnly || hasOptionsOnly;
if (args["--help"] || !hasValidInput) {
  printHelp();
  process.exit(hasValidInput ? 0 : 1);
}
if (args["--version"]) {
  printVersion();
  process.exit(0);
}
if (args["--input"]) {
  inputFileName = args["--input"];
}
if (args["--output"]) {
  outputFileName = args["--output"];
}
if (args._.length === 2) {
  [inputFileName, outputFileName] = args._;
}
if (args["--config"]) {
  configFiles = args["--config"];
}
if (args._.length === 1) {
  configFiles = args._;
}
if (inputFileName && outputFileName) {
  await buildWasm({
    input: inputFileName,
    output: outputFileName
  });
  colorLog("success", `Build success!!`);
  colorLog("info", `"${inputFileName}" -> "${outputFileName}"`);
  process.exit(0);
}
if (configFiles.length > 0 && configFiles[0].length > 0) {
  await buildFromConfigFiles(configFiles);
  process.exit(0);
}
printHelp();
process.exit(1);
